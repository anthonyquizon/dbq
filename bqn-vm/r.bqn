
# f: lazy function to construct hashmap of variables
Replâ‡{ğ•Š vmap:
  io.term.RawMode 1
  io.term.OutRaw â€¢ToUTF8 prompt
  io.term.Flush@

  vmapâ†©Vmap @ â‹„ châ†âŸ¨âŸ© â‹„ psâ†0 # vmap: variable mappings. ch: character buffer. ps: cursor offset
  hooksâ†{_Preâ‡_Postâ‡{_ğ•£:@}â‹„Errâ‡VMCatch}
  bkt_nextâ†©0

  Cmdâ†{
    ch ğ•ŠÂ·: ""â‰¡Trim ch? # ignore empty statements
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœprompt
      1  
  ; ch ğ•ŠÂ·:
      io.term.OutRaw clear
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœpromptâˆ¾ch
      inâ†"x__argâ€¿w__argâ†â€¢args â‹„ w__arg {ğ•Š:"âˆ¾châˆ¾"} x__arg" # HACK: wrap in function via string manipulation to expose ğ•Š ğ•¨ ğ•© variables 
      cm â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System vmap.GetÂ¨"ğ•©ğ•¨", vmap.Keys@âŸ©âŠ¸Compile)âŠ(""âŠ¸({ğ•Š:@}_CmpCatch)) in
      {@:1; io.Out hooksâ€¿vmapâ€¿@ vm.Eval ğ•©} cm
      1
  }

  Continueâ†{ğ•Š:io.term.OutRaw lfâˆ¾Ëœ"Continue"â‹„bkt_nextâ†©0â‹„0}
  Next    â†{ğ•Š:bkt_nextâ†©1â‹„0} 

  Patchâ†{0=â‰ ch?âŸ¨âŸ©;âˆ¾(âˆ¾âŸœğ•©(-ğ•¨)âŠ¸â†“)Â¨âŒ¾(1âŠ¸â†‘) ps(âŠ¢âŠ”Ëœâ‰¤âŸœ(â†•â‰ ))ch} # add ğ•© into ch at ps position with ğ•¨ deletions

  # Tip: use `cat -v` in the terminal to find out key codes
  Mapâ†{ # map of inputs to âŸ¨ch, ps, effâŸ©. ch: new character list, ps: position, eff: side effect functionâŸ© 
    ğ•©:ğ•©â‰¡eâˆ¾"[D"             ? âŸ¨ch,            0âŒˆps-1,          1          âŸ© # arrow left
  ; ğ•©:ğ•©â‰¡eâˆ¾"[C"             ? âŸ¨ch,            (â‰ ch)âŒŠps+1,      1          âŸ© # arrow right
  ; ğ•©:ğ•©â‰¡eâˆ¾"[46;5u"         ? âŸ¨âŸ¨âŸ©,            0,               Next       âŸ© # ctrl+; next bytecode
  ; ğ•©:ğ•©â‰¡eâˆ¾"[109;5u"        ? âŸ¨âŸ¨âŸ©,            0,               1          âŸ© # 
  ; ğ•©:ğ•©â‰¡eâˆ¾"[27;5;13~"        ? âŸ¨âŸ¨âŸ©,           0,              Continue   âŸ© # ctrl+enter
  ; ğ•©:ğ•©â‰¡â‰@+10              ? âŸ¨âŸ¨âŸ©,            0,               châŠ¸Cmd     âŸ© # enter and run command
  ; ğ•©:ğ•©â‰¡â‰@+127             ? âŸ¨1 Patch "",    0âŒˆps-1,          1          âŸ© # backspace
  ; ğ•©:ğ•©â‰¡â‰@+21              ? âŸ¨âŸ¨âŸ©,            0,               1          âŸ© # ctrl+u
  ; ğ•©:ğ•©â‰¡â‰@+3               ? âŸ¨âŸ¨âŸ©,            0,               {ğ•Š:â€¢Exit 0}âŸ© # ctrl+c
  ; ğ•©:0=â‰ ch                ? âŸ¨ğ•©,             1,               1          âŸ©
  # TODO add command
  ; ğ•©:'\'=ch(âŠ£âŠ‘Ëœ0âŒˆâ‰ âŠ¸âŒŠ)ps-1 ? zâ†uni/ËœascâˆŠğ•©
                             âŸ¨ch0â†1 Patch z, (â‰ z)+ps-1,       1          âŸ© # replace '/' with unicode chars
  ; ğ•©:                       âŸ¨ch0â†0 Patch ğ•©, ps+1,            1          âŸ© 
  }

  # if e consume chars until letter (ANSI format parsing)
  Inputâ†{
     ğ•Š@:ğ•Šio.In@
  ;  ğ•Šğ•©:ğ•©=e?ğ•©âˆ¾eğ•Šio.In@ 
  ;  ğ•Šğ•©:âŸ¨ğ•©âŸ©
  ; eğ•Šğ•©:âŠ‘ğ•©âˆŠâˆ¾'~'âˆ¾+âŸœ(â†•26)Â¨"Aa"?ğ•©
  ; eğ•Šğ•©:ğ•©âˆ¾eğ•Šio.In@
  }

  {ğ•Š:
    effâ†@â‹„châ€¿psâ€¿Effâ†©Map Input@
    retâ†Eff @

    io.term.OutRaw clear # clear line and set to start of line
    io.term.OutRaw â€¢ToUTF8 prompt
    io.term.OutRaw â€¢ToUTF8 ch
    io.term.OutRaw eâˆ¾"["âˆ¾(â€¢Fmt (â‰ prompt)+ps+1)âˆ¾"G"
    io.term.Flush@
    ret
  }â€¢_while_ âŠ¢ 1

  io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ""
}
