# Reference: https://github.com/anthonyquizon/vbqn/blob/main/src/v.bqn
gl      ←    •Import "glyphs.bqn"
compile ← gl •Import "c.bqn"
vm      ←    •Import "vm.bqn"

io←{⟨Out,Show,CharB,RawMode,OutRaw,Flush⟩⇐•args}

e←@+27 ⋄ lf←@+10 ⋄ clear←e∾"[2K"∾e∾"[0G"
boldCyan←e∾"[1;36m"
red     ←e∾"[31m"
magenta ←e∾"[35m"
boldRed ←e∾"[1;31m"
reset   ←e∾"[0m"

prompt←"    "

asc←"`1234567890-=~!@#$%^&*()_+qwertyuiop[]QWERTYUIOP{}asdfghjkl;''ASDFGHJKL:""|zxcvbnm,./ZXCVBNM<>?"
uni←"˜˘¨⁼⌜´˝7∞¯•÷×¬⎉⚇⍟◶⊘⎊⍎⍕⟨⟩√⋆⌽𝕨∊↑∧y⊔⊏⊐π←→↙𝕎⍷𝕣⍋YU⊑⊒⍳⊣⊢⍉𝕤↕𝕗𝕘⊸∘○⟜⋄↩\↖𝕊D𝔽𝔾«J⌾»·˙|⥊𝕩↓∨⌊n≡∾≍≠⋈𝕏C⍒⌈N≢≤≥⇐"

# imports: filename→⟨result, source code⟩
imports←⟨⟩ •HashMap ⟨⟩ 

ctx‿dbg ← {𝕊:{
  s    ⇐ ⟨⟩
  Push ⇐ {𝕊:s∾↩<𝕩}
  Peek ⇐ {𝕊:0=≠s?⟨⟩;¯1⊑s}               # Return but don't pop top value
  Pop  ⇐ {t←-𝕩⋄(s↓˜↩t)⊢⌽t↑s}            # Pop 𝕩 values; return as list
}}¨↕2

sysfile←{
  Lines⇐{ 
    𝕩 : "/"≤○≠◶0‿(⊣≡≠⊸↑)𝕩 ? •file.Lines 𝕩 
  ; 𝕩 : •file.Lines ∾⟜𝕩 •file.Parent ctx.Peek @ ⋄ 
  } 
  List ⇐{ •file.List ∾⟜𝕩 •file.Parent ctx.Peek @ } 
}

syslist←⟨
    "while"‿•_while_
    "hash"‿•Hash
    "parsefloat"‿•ParseFloat
    "ffi"‿•FFI
    "out"‿io.Out
    "exit"‿•Exit
    "file"‿sysfile
    "flines"‿sysfile.Lines
    "math"‿•math
    "ns"  ‿•ns
    "show"‿io.Show
    "bqn"‿•Bqn
    "repr"‿•Repr
    "type"‿•Type
⟩

System ←{ 𝕊 args:
  F ← {                                                                                 # find system function
    i ← 𝕨⊐𝕩 ⋄ {!∾⟨"Unknown system value",(1≠≠𝕩)/"s",":"⟩∾" •"⊸∾¨𝕩}∘/⟜𝕩⍟(∨´) i=≠𝕨 ⋄ i
  }
  {𝕨⊸F⊏𝕩˙}´∾<˘⋈˘⍉>syslist∾⟨"import"‿Import, "args"‿𝕩⟩
}

# shows compiler errors
CmpCatch←{ f 𝕊 src:
  l←+`src=lf ⋄ sl←(lf⊸≠)⊸/¨src⊔˜»+`lf=src                  # l: line numbers, sl: source file in lines
  ⟨loc,msg⟩←•CurrentError@⋄s‿e←loc↩⥊loc
  io.Out "Error: "∾msg
  io.Out f∾":"∾ •Fmt s⊑sl
  io.Out (s⊑l)⊑sl
  io.Out ⊣◶" ∧"¨«((↕≠src)/˜∨´l⊸=¨loc⊏l)∊s+↕1+e-s
  •Exit 1
}

VMCatch⇐{·𝕊env:
  io.Out ∾⟨boldRed,"Error: ", •CurrentError@, reset⟩
  {𝕊 f‿pos : 
    ⟨·,cm,s⟩←imports.Get f ⋄ ·‿·‿·‿·‿loc‿·←cm
    c←∾(↕≠)¨⊔˜+`s=@+10 ⋄ l←+`s=lf
    sl←(lf⊸≠)⊸/¨s⊔˜»+`lf=s

    o←|-´(pos-1)⊑¨loc     # offset
    c↩c⊑˜1-˜⊑(pos-1)⊑¨loc # column
    l↩1+l⊑˜pos⊑⊑loc       # line
    io.Out ∾⟨red, f/˜¬(1¨↕1-˜≠p)∾(p←•wdpath∾'/')⍷f,':',•Fmt l, reset⟩
    io.Out ∾⟨"  ",(l-1)⊑sl⟩
    io.Out ∾⟨red, "  ",(' '¨↕c), '∧'¨↕o+1, reset⟩
  }¨⌽dbg.s
  Repl env
}

# Hooks to run in VM
hooks←{
  Pre⇐{𝕊 pos: dbg.Push ⟨ctx.Peek @,pos⟩ }
  Post⇐{𝕩}
  Err⇐VMCatch
}

# Wrap namespace to vm compatable namespace 
AdaptConst ← { 𝕊 bc‿consts‿blockInfo‿bodyInfo‿loc‿token:
  consts {
    𝕊 ns: 6≡•Type ns ?
      Field⇐{p𝕊i: Get ⇐ {𝕊:ns •ns.Get i⊑p.names}}
  ; 𝕊 𝕩: 𝕩
  }¨↩
  bc‿consts‿blockInfo‿bodyInfo‿loc‿token
}

Import ⇐ {
    𝕊 𝕩     : ⟨⟩ 𝕊 𝕩
; 𝕨 𝕊 ⟨f⇐f⟩ : imports.Has f ? 
    ≠⟜@◶⟨𝕨⊸𝕊⟜𝕩,⊢⟩ ⊑imports.Get f # if imports result is not realized
; 𝕨 𝕊 ⟨f⇐f⟩ : 
    s←•file.Chars f 
    ctx.Push f
      cm ← (⟨1⊸⊑¨•primitives, System 𝕨, ⟨⟩⟩⊸Compile)⎊(f⊸CmpCatch) s
      cm ↩ AdaptConst cm
      f imports.Set ⟨@,cm,s⟩
      f imports.Set ⟨r←hooks VM cm,cm,s⟩
    ctx.Pop 1 
    r
; 𝕨 𝕊 𝕩 :  # canonicalize filename
    f←'/'⊸∾⍟(¬∘∨´"./"⊸⍷) 𝕩
    f↩𝕩∾˜(0⊸≢≠)◶""‿•file.Parent ctx.Peek @     # resolve relative file location
    𝕨 𝕊 {f⇐f}
}

EnvMap←{ # convert env into hashmap walk up tree to accumulate values
    𝕊 𝕩: (⟨⟩ •HashMap ⟨⟩) 𝕊 𝕩
; h 𝕊 𝕩: 𝕩 •ns.Has "parent" ?
    n←{𝕩.n}¨𝕩.vars
    v←{𝕩.v}¨𝕩.vars
    n {𝕨 {𝕨 h.Set 𝕩}⍟(¬∘h.Has⊢) 𝕩}¨v
    h 𝕊 𝕩.parent
    h
; h 𝕊 ·: h
}

Repl⇐{𝕊 env:
  env EnvMap ↩
  io.RawMode 1
  io.OutRaw prompt

  r←•ReBQN {system⇐⟨"args"‿(env.Values@)⟩}
  Eval←{R ∾⟨"⟨",1↓∾','⊸∾¨(env.Keys@),"⟩←•args",lf,𝕩⟩}

  ch←⟨⟩ ⋄ ps←0 # ch: character buffer. ps: cursor offset
  Cmd←{ch𝕊·:
    io.OutRaw clear
    io.Show Eval⎊•CurrentError ch
    1
  }

  Patch←{0=≠ch?⟨⟩;∾(∾⟜𝕩(-𝕨)⊸↓)¨⌾(1⊸↑) ps(⊢⊔˜≤⟜(↕≠))ch} # add 𝕩 into ch at ps position with 𝕨 deletions

  Map←{ # map of inputs to ⟨ch, ps, eff⟩. ch: new character list, ps: position, eff: side effect function⟩ 
    𝕩:𝕩≡e∾"[D"             ? ⟨ch,            0⌈ps-1,          1   ⟩ # arrow left
  ; 𝕩:𝕩≡e∾"[C"             ? ⟨ch,            (≠ch)⌊ps+1,      1   ⟩ # arrow right
  ; 𝕩:𝕩≡≍@+10              ? ⟨⟨⟩,            0,               ch⊸Cmd⟩ # enter and run command
  ; 𝕩:𝕩≡≍@+127             ? ⟨1 Patch "",    0⌈ps-1,          1   ⟩ # backspace
  ; 𝕩:𝕩≡≍@+21              ? ⟨⟨⟩,            0,               1   ⟩ # ctrl+u
  ; 𝕩:𝕩≡≍@+3               ? ⟨⟨⟩,            0,               0   ⟩ # ctrl+c
  ; 𝕩:0=≠ch                ? ⟨𝕩,             1,               1   ⟩
  ; 𝕩:'\'=ch(⊣⊑˜0⌈≠⊸⌊)ps-1 ? z←uni/˜asc∊𝕩
                             ⟨ch0←1 Patch z, (≠z)+ps-1,       1   ⟩ # replace '/' with unicode chars
  ; 𝕩:                       ⟨ch0←0 Patch 𝕩, ps+1,            1   ⟩ 
  }

  # if e consume chars until letter (ANSI format for keypimportsses)
  Input←{
     𝕊@:𝕊io.CharB@
  ;  𝕊𝕩:𝕩=e?𝕩∾e𝕊io.CharB@
  ;  𝕊𝕩:⟨𝕩⟩
  ; e𝕊𝕩:⊑𝕩∊∾+⟜(↕26)¨"Aa"?𝕩
  ; e𝕊𝕩:𝕩∾e𝕊io.CharB@
  }

  {𝕊:
    eff←@⋄ch‿ps‿Eff↩Map Input@
    ret←Eff @

    io.OutRaw clear # clear line and set to start of line
    io.OutRaw prompt
    io.OutRaw ch
    io.OutRaw e∾"["∾(•Fmt (≠prompt)+ps+1)∾"G"
    io.Flush@
    ret
  }•_while_ ⊢ 1
}
