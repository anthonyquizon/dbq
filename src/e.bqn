# Reference: https://github.com/anthonyquizon/vbqn/blob/main/src/v.bqn
gl      â†    â€¢Import "glyphs.bqn"
compile â† gl â€¢Import "c.bqn"
vm      â†    â€¢Import "vm.bqn"

ioâ†â€¢args

eâ†@+27 â‹„ lfâ†@+10 â‹„ clearâ†eâˆ¾"[2K"âˆ¾eâˆ¾"[0G"
boldCyanâ†eâˆ¾"[1;36m"
red     â†eâˆ¾"[31m"
magenta â†eâˆ¾"[35m"
boldRed â†eâˆ¾"[1;31m"
reset   â†eâˆ¾"[0m"

flag_stepâ†0

promptâ†"    "

ascâ†"`1234567890-=~!@#$%^&*()_+qwertyuiop[]QWERTYUIOP{}asdfghjkl;''ASDFGHJKL:""|zxcvbnm,./ZXCVBNM<>? "
uniâ†"ËœË˜Â¨â¼âŒœÂ´Ë7âˆÂ¯â€¢Ã·Ã—Â¬â‰âš‡âŸâ—¶âŠ˜âŠââ•âŸ¨âŸ©âˆšâ‹†âŒ½ğ•¨âˆŠâ†‘âˆ§yâŠ”âŠâŠÏ€â†â†’â†™ğ•â·ğ•£â‹YUâŠ‘âŠ’â³âŠ£âŠ¢â‰ğ•¤â†•ğ•—ğ•˜âŠ¸âˆ˜â—‹âŸœâ‹„â†©\â†–ğ•ŠDğ”½ğ”¾Â«JâŒ¾Â»Â·Ë™|â¥Šğ•©â†“âˆ¨âŒŠnâ‰¡âˆ¾â‰â‰ â‹ˆğ•Câ’âŒˆNâ‰¢â‰¤â‰¥â‡â€¿"

importsâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© 

# opt codes to break for
hook_opsâ†âŸ¨
  16,17,20,21,26,27,   # Application
  18,19,23,22          # Application with Nothing
  47,48,49,50,51       # Assignment
âŸ©

Trimâ†((âˆ¨`âˆ§âˆ¨âŸœÂ«)' 'âŠ¸â‰ )âŠ¸/

ctxâ€¿dbg â† {ğ•Š:{
  s    â‡ âŸ¨âŸ©
  Push â‡ {ğ•Š:sâˆ¾â†©<ğ•©}
  Peek â‡ {ğ•Š:0=â‰ s?âŸ¨âŸ©;Â¯1âŠ‘s}               # Return but don't pop top value
  Pop  â‡ {tâ†-ğ•©â‹„(sâ†“Ëœâ†©t)âŠ¢âŒ½tâ†‘s}            # Pop ğ•© values; return as list
}}Â¨â†•2

sysfileâ†{
  Linesâ‡{ 
    ğ•© : "/"â‰¤â—‹â‰ â—¶0â€¿(âŠ£â‰¡â‰ âŠ¸â†‘)ğ•© ? â€¢file.Lines ğ•© 
  ; ğ•© : â€¢file.Lines âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ â‹„ 
  } 
  List â‡{ â€¢file.List âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ } 
}

syslistâ†âŸ¨
    "while"â€¿â€¢_while_
    "hash"â€¿â€¢Hash
    "parsefloat"â€¿â€¢ParseFloat
    "ffi"â€¿â€¢FFI
    "out"â€¿â€¢Out
    "exit"â€¿â€¢Exit
    "file"â€¿sysfile
    "flines"â€¿sysfile.Lines
    "math"â€¿â€¢math
    "ns"  â€¿â€¢ns
    "show"â€¿â€¢Show
    "bqn"â€¿â€¢Bqn
    "repr"â€¿â€¢Repr
    "type"â€¿â€¢Type
âŸ©

System â†{
  F â† {                                                                                 # find system function
    i â† ğ•¨âŠğ•© â‹„ {!âˆ¾âŸ¨"Unknown system value",(1â‰ â‰ ğ•©)/"s",":"âŸ©âˆ¾" â€¢"âŠ¸âˆ¾Â¨ğ•©}âˆ˜/âŸœğ•©âŸ(âˆ¨Â´) i=â‰ ğ•¨ â‹„ i
  }
  {ğ•¨âŠ¸FâŠğ•©Ë™}Â´âˆ¾<Ë˜â‹ˆË˜â‰>syslistâˆ¾âŸ¨"import"â€¿Import, "args"â€¿ğ•©âŸ©
}

# shows compiler errors
_CmpCatchâ†{ f Exit _ğ•£ src:
  lâ†+`src=lf â‹„ slâ†(lfâŠ¸â‰ )âŠ¸/Â¨srcâŠ”ËœÂ»+`lf=src                  # l: line numbers, sl: source file in lines
  âŸ¨loc,msgâŸ©â†â€¢CurrentError@â‹„sâ€¿eâ†locâ†©â¥Šloc
  io.term.OutRaw lfâˆ¾Ëœ"Error: "âˆ¾msg
  #io.term.OutRaw lfâˆ¾Ëœfâˆ¾":"âˆ¾ â€¢Fmt sâŠ‘sl
  io.term.OutRaw lfâˆ¾Ëœ(sâŠ‘l)âŠ‘sl
  io.term.OutRaw lfâˆ¾ËœâŠ£â—¶" âˆ§"Â¨Â«((â†•â‰ src)/Ëœâˆ¨Â´lâŠ¸=Â¨locâŠl)âˆŠs+â†•1+e-s
  Exit 1
}

VMCatchâ‡{ğ•Š Â·:
  io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœâˆ¾âŸ¨boldRed,"Error: ", â€¢CurrentError@, resetâŸ©
  {ğ•Š fâ€¿pos : 
    ğ•©
    âŸ¨line, cmâŸ©â†imports.Get f â‹„ Â·â€¿Â·â€¿Â·â€¿Â·â€¿locâ€¿Â·â†cm
    #câ†âˆ¾(â†•â‰ )Â¨âŠ”Ëœ+`s=@+10 â‹„ lâ†+`s=lf â‹„ slâ†(lfâŠ¸â‰ )âŠ¸/Â¨sâŠ”ËœÂ»+`lf=s 
    #oâ†|-Â´(pos-1)âŠ‘Â¨loc     # offset 
    #câ†©câŠ‘ËœâŠ‘(pos-1)âŠ‘Â¨loc # column
    #lâ†©1+lâŠ‘ËœposâŠ‘âŠ‘loc       # line

    #lnâ†(l-1)âŠ‘sl
    #hâ€¿mâ€¿tâ†3â†‘lnâŠ”Ëœ+`((1+o+c)âŠ¸=âˆ¨câŠ¸=)â†•â‰ ln
    #â€¢Out âˆ¾âŸ¨magenta,f/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·f,':',â€¢Fmt l,resetâŸ©
    #â€¢Out âˆ¾âŸ¨"  ",h,boldRed,m,reset,tâŸ©

    ##-- cbqn like stack trace --
    #io.term.OutRaw lfâˆ¾Ëœâˆ¾âŸ¨f/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·f,':',â€¢Fmt lâŸ©
    #io.term.OutRaw lfâˆ¾Ëœâˆ¾âŸ¨"  ",(l-1)âŠ‘slâŸ©
    #io.term.OutRaw lfâˆ¾Ëœâˆ¾âŸ¨red, "  ",(' 'Â¨â†•c), 'âˆ§'Â¨â†•o+1, resetâŸ©
  }Â¨dbg.s
}

_PreHookâ†{f _ğ•£ pos: 
  âŸ¨cm,src,cols,line,breakâŸ©â†imports.Get fileâ†ctx.Peek @ â‹„ bcâ€¿Â·â€¿Â·â€¿Â·â€¿locâ€¿Â·â†cm

  {ğ•Š: 
    slâ†(lfâŠ¸â‰ )âŠ¸/Â¨srcâŠ”ËœÂ»+`lf=src
    oâ†|-Â´posâŠ‘Â¨loc     # offset 
    câ†colsâŠ‘ËœâŠ‘posâŠ‘Â¨loc # column
    lâ†1+lineâŠ‘ËœposâŠ‘âŠ‘loc       # line

    # TODO highlight line
    # TODO print previous and next lines

    lnâ†(l-1)âŠ‘sl
    hâ€¿mâ€¿tâ†3â†‘lnâŠ”Ëœ+`((1+o+c)âŠ¸=âˆ¨câŠ¸=)â†•â‰ ln
    io.term.OutRaw â€¢ToUTF8     âˆ¾âŸ¨magenta,file/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·file,':',â€¢Fmt l,resetâŸ©
    io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœâˆ¾âŸ¨"  ",h,magenta,m,reset,tâŸ©

    Repl f
  }âŸâŠ£ flag_stepâˆ¨âˆ¨Â´posâ·break

  dbg.Push âŸ¨file,posâŸ© 
}

# Hooks to run in VM
hooksâ†{
  _Preâ‡_PreHook
  Errâ‡{VMCatch ğ•© â‹„ Repl ğ•© }
}

# Wrap namespace to vm compatable namespace 
Import â† {
    ğ•Š ğ•©     : âŸ¨âŸ© ğ•Š ğ•©
; ğ•¨ ğ•Š âŸ¨fâ‡fâŸ© : imports.Has f ? (imports.Get f).Get @
; ğ•¨ ğ•Š âŸ¨fâ‡fâŸ© : 
    sâ†â€¢file.Chars f 
    cm â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System ğ•¨, âŸ¨âŸ©âŸ©âŠ¸Compile)âŠ(fâŠ¸(â€¢Exit _CmpCatch)) s
    bcâ€¿Â·â€¿Â·â€¿Â·â€¿locâ€¿Â·â†cm â‹„ iâ€¿Â·â†loc # i: index of start position of bytecodes

    # construct break points
    lâ†+`s=lf                    # lines
    mâ†bcâˆŠhook_ops               # mask of valid break positions
    bpâ†/(âˆ¨Â´"??"âŠ¸â·)Â¨sâŠ”Ëœ+`s=lf    # find lines with break point marks
    bpâ†©bpâˆŠËœiâŠl                  # map to bytecode positions
    bpâ†©bpâˆ§(bcâ‰ 6)                # separate by pop instructions (6)
    bpâ†©1â†“(â†•â‰ bc)âŠ”Ëœmâˆ§bpÃ—+`Â»âŠ¸<bp   # break point index groups
    bpâ†©âŠ‘Â¨bp/Ëœ(0â‰ â‰ )Â¨bp

    # Saved data for imports
    nsâ†{
      line  â‡ l                 # delete?
      cols  â‡ âˆ¾(â†•â‰ )Â¨âŠ”Ëœ+`s=@+10  # delete?
      break â‡ bp                # break point bytecode mask - accessed by pos
      cm    â‡ cm                # compilation result
      src   â‡ s                 # raw source code (helps for debugging)

      Get    â‡ !âˆ˜"Import result referenced before completion"
      SetRet â‡ {ğ•Š v: Getâ†©{ğ•Š:v}}
    }

    ctx.Push f
    f imports.Set ns
    ns.SetRet retâ†hooksâ€¿{Hasâ‡0Ë™} vm.Eval cm
    ctx.Pop 1 
    ret
; ğ•¨ ğ•Š ğ•© :  # canonicalize filename
    fâ†'/'âŠ¸âˆ¾âŸ(Â¬âˆ˜âˆ¨Â´"./"âŠ¸â·) ğ•©
    fâ†©ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿â€¢file.Parent ctx.Peek @     # resolve relative file location
    ğ•¨ ğ•Š {fâ‡f}
}

Run â‡ {
  Import ğ•©
  io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ"Done"
}

# f: lazy function to construct hashmap of variables
Replâ‡{ğ•Š f:
  io.term.RawMode 1
  io.term.OutRaw â€¢ToUTF8 prompt
  io.term.Flush@

  vmapâ†F @ â‹„ châ†âŸ¨âŸ© â‹„ psâ†0 # vmap: variable mappings. ch: character buffer. ps: cursor offset
  hooksâ†{_Preâ‡{_ğ•£:@}â‹„Errâ‡VMCatch}
  flag_stepâ†©0

  Cmdâ†{
    ch ğ•ŠÂ·: ""â‰¡Trim ch? # ignore empty statements
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœprompt
      1  
  ; ch ğ•ŠÂ·:
      io.term.OutRaw clear
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœpromptâˆ¾ch
      inâ†"xâ€¿wâ†â€¢args â‹„ w {ğ•Š:"âˆ¾châˆ¾"} x" # HACK: wrap in function via string manipulation to expose ğ•Š ğ•¨ ğ•© variables
      cm â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System vmap.GetÂ¨"ğ•©ğ•¨", vmap.Keys@âŸ©âŠ¸Compile)âŠ(""âŠ¸({ğ•Š:@}_CmpCatch)) in
      {@:1; io.Out hooksâ€¿vmap vm.Eval ğ•©} cm
      1
  }

  Continueâ†{ğ•Š:io.term.OutRaw lfâˆ¾Ëœ"Continue"â‹„flag_stepâ†©0â‹„0}
  Next    â†{ğ•Š:flag_stepâ†©1â‹„0} 

  Patchâ†{0=â‰ ch?âŸ¨âŸ©;âˆ¾(âˆ¾âŸœğ•©(-ğ•¨)âŠ¸â†“)Â¨âŒ¾(1âŠ¸â†‘) ps(âŠ¢âŠ”Ëœâ‰¤âŸœ(â†•â‰ ))ch} # add ğ•© into ch at ps position with ğ•¨ deletions

  # Tip: use `cat -v` in the terminal to find out key codes
  Mapâ†{ # map of inputs to âŸ¨ch, ps, effâŸ©. ch: new character list, ps: position, eff: side effect functionâŸ© 
    ğ•©:ğ•©â‰¡eâˆ¾"[D"             ? âŸ¨ch,            0âŒˆps-1,          1          âŸ© # arrow left
  ; ğ•©:ğ•©â‰¡eâˆ¾"[C"             ? âŸ¨ch,            (â‰ ch)âŒŠps+1,      1          âŸ© # arrow right
  ; ğ•©:ğ•©â‰¡eâˆ¾"[44;5u"         ? âŸ¨âŸ¨âŸ©,            0,               Continue   âŸ© # ctrl+. continue
  ; ğ•©:ğ•©â‰¡eâˆ¾"[46;5u"         ? âŸ¨âŸ¨âŸ©,            0,               Next       âŸ© # ctrl+; next bytecode
  ; ğ•©:ğ•©â‰¡â‰@+10              ? âŸ¨âŸ¨âŸ©,            0,               châŠ¸Cmd     âŸ© # enter and run command
  ; ğ•©:ğ•©â‰¡â‰@+127             ? âŸ¨1 Patch "",    0âŒˆps-1,          1          âŸ© # backspace
  ; ğ•©:ğ•©â‰¡â‰@+21              ? âŸ¨âŸ¨âŸ©,            0,               1          âŸ© # ctrl+u
  ; ğ•©:ğ•©â‰¡â‰@+3               ? âŸ¨âŸ¨âŸ©,            0,               {ğ•Š:â€¢Exit 0}âŸ© # ctrl+c
  ; ğ•©:0=â‰ ch                ? âŸ¨ğ•©,             1,               1          âŸ©
  ; ğ•©:'\'=ch(âŠ£âŠ‘Ëœ0âŒˆâ‰ âŠ¸âŒŠ)ps-1 ? zâ†uni/ËœascâˆŠğ•©
                             âŸ¨ch0â†1 Patch z, (â‰ z)+ps-1,       1          âŸ© # replace '/' with unicode chars
  ; ğ•©:                       âŸ¨ch0â†0 Patch ğ•©, ps+1,            1          âŸ© 
  }

  # if e consume chars until letter (ANSI format for keypimportsses)
  Inputâ†{
     ğ•Š@:ğ•Šio.In@
  ;  ğ•Šğ•©:ğ•©=e?ğ•©âˆ¾eğ•Šio.In@ 
  ;  ğ•Šğ•©:âŸ¨ğ•©âŸ©
  ; eğ•Šğ•©:âŠ‘ğ•©âˆŠâˆ¾+âŸœ(â†•26)Â¨"Aa"?ğ•©
  ; eğ•Šğ•©:ğ•©âˆ¾eğ•Šio.In@
  }

  {ğ•Š:
    effâ†@â‹„châ€¿psâ€¿Effâ†©Map Input@
    retâ†Eff @

    io.term.OutRaw clear # clear line and set to start of line
    io.term.OutRaw â€¢ToUTF8 prompt
    io.term.OutRaw â€¢ToUTF8 ch
    io.term.OutRaw eâˆ¾"["âˆ¾(â€¢Fmt (â‰ prompt)+ps+1)âˆ¾"G"
    io.term.Flush@
    ret
  }â€¢_while_ âŠ¢ 1

  io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ""
}
