# Reference: https://github.com/anthonyquizon/vbqn/blob/main/src/v.bqn
gl      â†    â€¢Import "glyphs.bqn"
compile â† gl â€¢Import "c.bqn"
vm      â†    â€¢Import "vm.bqn"

ioâ†{âŸ¨Out,Show,CharB,RawMode,OutRaw,FlushâŸ©â‡â€¢args}

eâ†@+27 â‹„ lfâ†@+10 â‹„ clearâ†eâˆ¾"[2K"âˆ¾eâˆ¾"[0G"

ascâ†"`1234567890-=~!@#$%^&*()_+qwertyuiop[]QWERTYUIOP{}asdfghjkl;''ASDFGHJKL:""|zxcvbnm,./ZXCVBNM<>?"
uniâ†"ËœË˜Â¨â¼âŒœÂ´Ë7âˆÂ¯â€¢Ã·Ã—Â¬â‰âš‡âŸâ—¶âŠ˜âŠââ•âŸ¨âŸ©âˆšâ‹†âŒ½ğ•¨âˆŠâ†‘âˆ§yâŠ”âŠâŠÏ€â†â†’â†™ğ•â·ğ•£â‹YUâŠ‘âŠ’â³âŠ£âŠ¢â‰ğ•¤â†•ğ•—ğ•˜âŠ¸âˆ˜â—‹âŸœâ‹„â†©\â†–ğ•ŠDğ”½ğ”¾Â«JâŒ¾Â»Â·Ë™|â¥Šğ•©â†“âˆ¨âŒŠnâ‰¡âˆ¾â‰â‰ â‹ˆğ•Câ’âŒˆNâ‰¢â‰¤â‰¥â‡"

importsâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ© 

ctxâ€¿dbg â† {
  s    â‡ ğ•©
  Push â‡ {ğ•Š:sâˆ¾â†©<ğ•©}
  Peek â‡ {ğ•Š:0=â‰ s?âŸ¨âŸ©;Â¯1âŠ‘s}                 # Return but don't pop top value
  Pop  â‡ {tâ†-ğ•©â‹„(sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s}            # Pop ğ•© values; return as list
}Â¨âŸ¨{fâ‡""}âŸ©â€¿âŸ¨âŸ©

# show compiler errors
CmpCatchâ†{ fâ€¿l ğ•Š src:
  slâ†(lfâŠ¸â‰ )âŠ¸/Â¨srcâŠ”ËœÂ»+`lf=src                  # source file in lines
  âŸ¨loc,msgâŸ©â†â€¢CurrentError@â‹„sâ€¿eâ†locâ†©â¥Šloc
  io.Out "Error: "âˆ¾msg
  io.Out fâˆ¾":"âˆ¾ â€¢Fmt sâŠ‘sl
  io.Out (sâŠ‘l)âŠ‘sl
  io.Out âŠ£â—¶" âˆ§"Â¨Â«((â†•â‰ src)/Ëœâˆ¨Â´lâŠ¸=Â¨locâŠl)âˆŠs+â†•1+e-s
  # TODO run repl
  â€¢Exit 1
}

sysfileâ†{
  Linesâ‡{ 
    ğ•© : "/"â‰¤â—‹â‰ â—¶0â€¿(âŠ£â‰¡â‰ âŠ¸â†‘)ğ•© ? â€¢file.Lines ğ•© 
  ; ğ•© : â€¢file.Lines âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ â‹„ 
  } 
  List â‡{ â€¢file.List âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ } 
}

syslistâ†âŸ¨
    "while"â€¿â€¢_while_
    "hash"â€¿â€¢Hash
    "parsefloat"â€¿â€¢ParseFloat
    "ffi"â€¿â€¢FFI
    "out"â€¿io.Out
    "exit"â€¿â€¢Exit
    "file"â€¿sysfile
    "flines"â€¿sysfile.Lines
    "math"â€¿â€¢math
    "ns"  â€¿â€¢ns
    "show"â€¿io.Show
    "bqn"â€¿â€¢Bqn
    "repr"â€¿â€¢Repr
    "type"â€¿â€¢Type
âŸ©

System â†{ ğ•Š args:
  F â† {                                                                                 # find system function
    i â† ğ•¨âŠğ•© â‹„ {!âˆ¾âŸ¨"Unknown system value",(1â‰ â‰ ğ•©)/"s",":"âŸ©âˆ¾" â€¢"âŠ¸âˆ¾Â¨ğ•©}âˆ˜/âŸœğ•©âŸ(âˆ¨Â´) i=â‰ ğ•¨ â‹„ i
  }
  {ğ•¨âŠ¸FâŠğ•©Ë™}Â´âˆ¾<Ë˜â‹ˆË˜â‰>syslistâˆ¾âŸ¨"import"â€¿Import, "args"â€¿ğ•©âŸ©
}

Import â‡ {
    ğ•Š ğ•© : âŸ¨âŸ© ğ•Š ğ•©
; Â· ğ•Š ğ•© : imports.Has ğ•© ? imports.Get ğ•©
; args ğ•Š ğ•© : 
    âŸ¨pâ‡fâŸ©â†ctx.Peek @
    fâ†'/'âŠ¸âˆ¾âŸ(Â¬âˆ˜âˆ¨Â´"./"âŠ¸â·) ğ•©
    fâ†©ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿â€¢file.Parent p     # resolve relative file location
    sâ†â€¢file.Chars f â‹„ câ†âˆ¾(â†•â‰ )Â¨âŠ”Ëœ+`s=@+10 â‹„ lâ†+`s=lf #s: src, f: file, c: columns, l: lines
    ctx.Push {fâ‡fâ‹„câ‡câ‹„lâ‡l} 
      bc â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System args, âŸ¨âŸ©âŸ©âŠ¸Compile)âŠ(fâ€¿lâŠ¸CmpCatch) s
      f imports.Set râ†VM bc
    ctx.Pop 1 
    r
}

Replâ‡{ğ•Š opt:
  io.RawMode 1
  io.OutRaw opt.prompt

  # ch: character buffer. ps: cursor offset
  châ†âŸ¨âŸ© â‹„ psâ†0 

  Cmdâ†{chğ•ŠÂ·:io.OutRaw clearâ‹„opt.Cmd ch}

  # add ğ•© into ch at ps position with ğ•¨ deletions
  Patchâ†{0=â‰ ch?âŸ¨âŸ©;âˆ¾(âˆ¾âŸœğ•©(-ğ•¨)âŠ¸â†“)Â¨âŒ¾(1âŠ¸â†‘) ps(âŠ¢âŠ”Ëœâ‰¤âŸœ(â†•â‰ ))ch} 

  # map of inputs to âŸ¨ch, ps, effâŸ© 
  # ch: new character list, ps: position, eff: side effect functionâŸ©
  Mapâ†{
    ğ•©:ğ•©â‰¡eâˆ¾"[D"             ? âŸ¨ch,            0âŒˆps-1,          {ğ•©}   âŸ© # arrow left
  ; ğ•©:ğ•©â‰¡eâˆ¾"[C"             ? âŸ¨ch,            (â‰ ch)âŒŠps+1,      {ğ•©}   âŸ© # arrow right
  ; ğ•©:ğ•©â‰¡â‰@+10              ? âŸ¨âŸ¨âŸ©,            0,               châŠ¸CmdâŸ© # enter and run command
  ; ğ•©:ğ•©â‰¡â‰@+127             ? âŸ¨1 Patch "",    0âŒˆps-1,          {ğ•©}   âŸ© # backspace
  ; ğ•©:ğ•©â‰¡â‰@+21              ? âŸ¨âŸ¨âŸ©,            0,               {ğ•©}   âŸ© # ctrl+u
  ; ğ•©:0=â‰ ch                ? âŸ¨ğ•©,             1,               {ğ•©}   âŸ©
  ; ğ•©:'\'=ch(âŠ£âŠ‘Ëœ0âŒˆâ‰ âŠ¸âŒŠ)ps-1 ? zâ†uni/ËœascâˆŠğ•©
                             âŸ¨ch0â†1 Patch z, (â‰ z)+ps-1,       {ğ•©}   âŸ© # replace '/' with unicode chars
  ; ğ•©:                       âŸ¨ch0â†0 Patch ğ•©, ps+1,            {ğ•©}   âŸ© 
  }

  # if e consume chars until letter (ANSI format for keypimportsses)
  Inputâ†{
     ğ•Š@:ğ•Šio.CharB@
  ;  ğ•Šğ•©:ğ•©=e?ğ•©âˆ¾eğ•Šio.CharB@
  ;  ğ•Šğ•©:âŸ¨ğ•©âŸ©
  ; eğ•Šğ•©:âŠ‘ğ•©âˆŠâˆ¾+âŸœ(â†•26)Â¨"Aa"?ğ•©
  ; eğ•Šğ•©:ğ•©âˆ¾eğ•Šio.CharB@
  }

  {ğ•Š:
    effâ†@â‹„châ€¿psâ€¿Effâ†©Map Input@
    Eff @

    io.OutRaw clear # clear line and set to start of line
    io.OutRaw opt.prompt
    io.OutRaw ch
    io.OutRaw eâˆ¾"["âˆ¾(â€¢Fmt (â‰ opt.prompt)+ps+1)âˆ¾"G"
    io.Flush@
  }â€¢_while_ 1 @
}
