gl      â†    â€¢Import "glyphs.bqn"
compile â† gl â€¢Import "c.bqn"
vm      â†    â€¢Import "vm.bqn"

fncâ†0 # flag no colour

ctxâ†@ â‹„ dbgâ†@
infmâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
resmâ†âŸ¨âŸ© â€¢HashMap âŸ¨âŸ©
lfâ†@+10

MakeStack â‡ {
  s â‡ ğ•©
  Push â‡ {ğ•Š: sâˆ¾â†©<ğ•©}
  Peek â‡ {ğ•Š: 0=â‰ s ? âŸ¨âŸ©;Â¯1âŠ‘s}                 # Return but don't pop top value
  Pop  â‡ {tâ†-ğ•© â‹„ (sâ†“Ëœâ†©t) âŠ¢ âŒ½tâ†‘s}             # Pop ğ•© values; return as list
}

CmpCatchâ†{ ğ•Š src:
  fâ†ctx.Peek@â‹„âŸ¨loc,msgâŸ©â†â€¢CurrentError@â‹„sâ€¿eâ†locâ†©â¥Šloc
  inâ†infm.Get f
  â€¢Out "Error: "âˆ¾msg
  â€¢Out fâˆ¾":"âˆ¾ â€¢Fmt sâŠ‘in.n
  â€¢Out (sâŠ‘in.n)âŠ‘in.l
  â€¢Out âŠ£â—¶" âˆ§"Â¨Â«((â†•â‰ src)/Ëœâˆ¨Â´in.nâŠ¸=Â¨locâŠin.n)âˆŠs+â†•1+e-s
  â€¢Exit 1
}

sysfileâ‡{
  Linesâ‡{ 
    ğ•© : "/"â‰¤â—‹â‰ â—¶0â€¿(âŠ£â‰¡â‰ âŠ¸â†‘)ğ•© ? â€¢file.Lines ğ•© 
  ; ğ•© : â€¢file.Lines âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ â‹„ 
  } 
  List â‡{ â€¢file.List âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ } 
}

syslistâ†âŸ¨
    "p"â€¿â€¢Show # TODO show file and line number
    "while"â€¿â€¢_while_
    "hash"â€¿â€¢Hash
    "parsefloat"â€¿â€¢ParseFloat
    "ffi"â€¿â€¢FFI
    "out"â€¿â€¢Out
    "exit"â€¿â€¢Exit
    "file"â€¿sysfile
    "flines"â€¿sysfile.Lines
    "math"â€¿â€¢math
    "ns"  â€¿â€¢ns
    "show"â€¿â€¢Show
    "bqn"â€¿â€¢Bqn
    "repr"â€¿â€¢Repr
    "type"â€¿â€¢Type
âŸ©

System â†{ ğ•Š args:
  F â† {                                                                                 # find system function
    i â† ğ•¨âŠğ•© â‹„ { ! âˆ¾âŸ¨"Unknown system value",(1â‰ â‰ ğ•©)/"s",":"âŸ©âˆ¾" â€¢"âŠ¸âˆ¾Â¨ğ•© }âˆ˜/âŸœğ•©âŸ(âˆ¨Â´) i=â‰ ğ•¨ â‹„ i
  }
  { ğ•¨âŠ¸FâŠğ•©Ë™ }Â´âˆ¾<Ë˜â‹ˆË˜â‰>syslistâˆ¾âŸ¨ "import"â€¿Import, "args"â€¿ğ•© âŸ©
}

Infoâ†{ 
  f â‡ ğ•©â‹„("Missing file "âˆ¾f)!â€¢file.Exists f # filename
  s â‡ â€¢file.Chars f                        # source files in chars
  l â‡ (lfâŠ¸â‰ )âŠ¸/Â¨sâŠ”ËœÂ»+`lf=s                  # source file in lines
  n â‡ +`s=lf                               # line numbers
  c â‡ âˆ¾(â†•â‰ )Â¨âŠ”Ëœ+`s=@+10                     # column numbers
  m â‡ â‰ /ËœâŒ½0<+`âŒ½Â¬(0âŠ¸=â‰ Â¨l)âˆ¨âˆ§Â´Â¨' 'âŠ¸=Â¨l        # maximum line number TODO delete - instead snap to nearest line above
}

Import â‡ {
    ğ•Š ğ•© : âŸ¨âŸ© ğ•Š ğ•©
; Â· ğ•Š ğ•© : resm.Has ğ•© ? resm.Get ğ•©
; args ğ•Š ğ•© : 
    fâ†'/'âŠ¸âˆ¾âŸ(Â¬âˆ˜âˆ¨Â´"./"âŠ¸â·) ğ•©
    fâ†©ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿â€¢file.Parent ctx.Peek @
    ctx.Push f
    f infm.Set inâ†Info f
    # TODO precompile
    r â† VM (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System args, âŸ¨âŸ©âŸ©âŠ¸Compile)âŠCmpCatch in.s
    f resm.Set r
    ctx.Pop 1 
    r
}

usageâ†âˆ¾âˆ¾âŸœlfÂ¨âŸ¨
  "Usage: vbqn [options] [file.bqn [arguments]]"
âŸ©

{
  ctxâ†©MakeStack âŸ¨âŸ©
  dbgâ†©MakeStack âŸ¨âŸ©

  {ğ•Š:â€¢Out usageâ‹„â€¢Exit 0}âŸ(0âŠ¸=)â‰ â€¢args 

  Import â€¢wdpathâˆ¾'/'âˆ¾âŠ‘â€¢args
}

