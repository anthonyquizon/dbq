# Reference: https://github.com/anthonyquizon/vbqn/blob/main/src/v.bqn
compile â† â€¢Import "c.bqn"
vm      â† â€¢Import "vm.bqn"

# TODO if args is namespace
# else use default namespace
ioâ†â€¢args

eâ†@+27 â‹„ lfâ†@+10 â‹„ clearâ†eâˆ¾"[2K"âˆ¾eâˆ¾"[0G"
boldCyanâ€¿redâ€¿magentaâ€¿boldRedâ€¿resetâ†eâŠ¸âˆ¾Â¨"[1;36m"â€¿"[31m"â€¿"[35m"â€¿"[1;31m"â€¿"[0m"
bkt_nextâ†0

promptâ†"    "

ascâ†"`1234567890-=~!@#$%^&*()_+qwertyuiop[]QWERTYUIOP{}asdfghjkl;''ASDFGHJKL:""|zxcvbnm,./ZXCVBNM<>? "
uniâ†"ËœË˜Â¨â¼âŒœÂ´Ë7âˆÂ¯â€¢Ã·Ã—Â¬â‰âš‡âŸâ—¶âŠ˜âŠââ•âŸ¨âŸ©âˆšâ‹†âŒ½ğ•¨âˆŠâ†‘âˆ§yâŠ”âŠâŠÏ€â†â†’â†™ğ•â·ğ•£â‹YUâŠ‘âŠ’â³âŠ£âŠ¢â‰ğ•¤â†•ğ•—ğ•˜âŠ¸âˆ˜â—‹âŸœâ‹„â†©\â†–ğ•ŠDğ”½ğ”¾Â«JâŒ¾Â»Â·Ë™|â¥Šğ•©â†“âˆ¨âŒŠnâ‰¡âˆ¾â‰â‰ â‹ˆğ•Câ’âŒˆNâ‰¢â‰¤â‰¥â‡â€¿"

importsâ†â€¢HashMapËœâŸ¨âŸ© 

instr â† (âŠ/Â¨1âŠ¸â†“)'0'-ËœâŸ¨ # For each instruction, number of:
  "11411311121111111315114131131111=111"  # Codes until next opcode
  "111000111100000000002221100000000111"  # Arguments
  "000111////23232303230000011022232111"  # Stack values consumed
  "111000111111111101111111101101111111"  # Stack values output
  "000000000011111101010000000000010000"  # Position determiner
âŸ©

dbg_opsâ†âŸ¨
  16,17,20,21,26,27,   # Application
  18,19,23,22          # Application with Nothing
âŸ©

Trimâ†((âˆ¨`âˆ§âˆ¨âŸœÂ«)' 'âŠ¸â‰ )âŠ¸/

ctxâ€¿dbg â† {ğ•Š:{
  s    â‡ âŸ¨âŸ©
  Push â‡ {ğ•Š:sâˆ¾â†©<ğ•©}
  Peek â‡ {ğ•Š:0=â‰ s?âŸ¨âŸ©;Â¯1âŠ‘s}               # Return but don't pop top value
  Pop  â‡ {tâ†-ğ•©â‹„(sâ†“Ëœâ†©t)âŠ¢âŒ½tâ†‘s}            # Pop ğ•© values; return as list
}}Â¨â†•2

sysfileâ†{
  Linesâ‡{ 
    ğ•© : "/"â‰¤â—‹â‰ â—¶0â€¿(âŠ£â‰¡â‰ âŠ¸â†‘)ğ•© ? â€¢file.Lines ğ•© 
  ; ğ•© : â€¢file.Lines âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @
  } 
  List â‡{ â€¢file.List âˆ¾âŸœğ•© â€¢file.Parent ctx.Peek @ } 
}

Showâ†{
  # TODO current line
  â€¢Show ğ•©
}

Breakâ†{bkt_nextâ†©1â‹„ğ•©}

syslistâ†âŸ¨
    "while"â€¿â€¢_while_
    "hash"â€¿â€¢Hash
    "parsefloat"â€¿â€¢ParseFloat
    "ffi"â€¿â€¢FFI
    "out"â€¿â€¢Out
    "exit"â€¿â€¢Exit
    "file"â€¿sysfile
    "flines"â€¿sysfile.Lines
    "math"â€¿â€¢math
    "term"â€¿â€¢term
    "break"â€¿Break
    "wdpath"â€¿â€¢wdpath
    "currenterror"â€¿â€¢CurrentError
    "hashmap"â€¿â€¢HashMap
    "toutf8"â€¿â€¢ToUTF8
    "ns"â€¿â€¢ns
    "show"â€¿Show
    "bqn"â€¿â€¢Bqn
    "fmt"â€¿â€¢Fmt
    "makerand"â€¿â€¢MakeRand
    "primitives"â€¿â€¢Primitives
    "repr"â€¿â€¢Repr
    "type"â€¿â€¢Type
âŸ©

# find system function
System â†{
  F â† {
    i â† ğ•¨âŠğ•©
    {!âˆ¾âŸ¨"Unknown system value",(1â‰ â‰ ğ•©)/"s",":"âŸ©âˆ¾" â€¢"âŠ¸âˆ¾Â¨ğ•©}âˆ˜/âŸœğ•©âŸ(âˆ¨Â´) i=â‰ ğ•¨ 
    i
  }
  {ğ•¨âŠ¸FâŠğ•©Ë™}Â´âˆ¾<Ë˜â‹ˆË˜â‰>syslistâˆ¾âŸ¨"import"â€¿Import, "args"â€¿ğ•©âŸ©
}

PrintStackTraceâ†{ğ•Š:
  {ğ•Š fâ€¿pos : 
    ğ•©
    âŸ¨line, cols, src, cmâŸ©â†imports.Get f â‹„ Â·â€¿Â·â€¿Â·â€¿Â·â€¿locâ€¿Â·â†cm
    slâ†(lfâŠ¸â‰ )âŠ¸/Â¨srcâŠ”ËœÂ»line
    oâ†|-Â´(pos-1)âŠ‘Â¨loc     # offset 
    câ†colsâŠ‘ËœâŠ‘(pos-1)âŠ‘Â¨loc # column
    lâ†1+lineâŠ‘ËœposâŠ‘âŠ‘loc    # line

    ##-- cbqn like stack trace --
    io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœâˆ¾âŸ¨f/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·f,':',â€¢Fmt lâŸ©
    io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœâˆ¾âŸ¨"  ",(l-1)âŠ‘slâŸ©
    io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœâˆ¾âŸ¨red, "  ",(' 'Â¨â†•c), 'âˆ§'Â¨â†•o+1, resetâŸ©
  }Â¨dbg.s
}

# shows compiler errors
_CmpCatchâ†{ f Exit _ğ•£ src:
  lâ†+`src=lf â‹„ slâ†(lfâŠ¸â‰ )âŠ¸/Â¨srcâŠ”ËœÂ»+`lf=src                  # l: line numbers, sl: source file in lines

  { ğ•Š locâ€¿msg:
      sâ€¿eâ†locâ†©â¥Šloc
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ"Error: "âˆ¾msg
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ(sâŠ‘l)âŠ‘sl
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾ËœâŠ£â—¶" âˆ§"Â¨Â«((â†•â‰ src)/Ëœâˆ¨Â´lâŠ¸=Â¨locâŠl)âˆŠs+â†•1+e-s
  ; ğ•Š ğ•©: 
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ"Error: "âˆ¾(â€¢Fmt ğ•©)
      PrintStackTrace @
  }â€¢CurrentError@
  Exit 1
}

VMCatchâ‡{ğ•Š Â·:
  io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœâˆ¾âŸ¨boldRed,"Error: ", â€¢CurrentError@, resetâŸ©
  PrintStackTrace @
}

_PreHookâ†{vmap _ğ•£ posâ€¿fileâ€¿stack: 
  âŸ¨cm,src,cols,line,break,printâŸ©â†imports.Get file â‹„ bcâ€¿Â·â€¿Â·â€¿Â·â€¿locâ€¿Â·â†cm

  {ğ•Š: 
    iâ†posâŠ‘âŠ‘loc â‹„ oâ†|-Â´posâŠ‘Â¨loc â‹„ câ†iâŠ‘cols â‹„ lâ†iâŠ‘line â‹„ lnâ†lâŠ‘lineâŠ”src # i: position from bc to src. o: offset between start and end postions. c: current column number. l: current line number. ln: current line as string
    hâ€¿mâ€¿tâ†3â†‘lnâŠ”Ëœ+`((1+o+c)âŠ¸=âˆ¨câŠ¸=)â†•â‰ ln # h: head, m: middle, t: tail
    io.term.OutRaw â€¢ToUTF8     âˆ¾âŸ¨magenta,file/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·file,':',â€¢Fmt l,resetâŸ© # TODO move this to repl?
    io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœâˆ¾âŸ¨"  ",h(âŠ£/Ëœâ‰ )lf,magenta,m,reset,tâŸ©
    Repl vmap
  }âŸâŠ£ bkt_nextâˆ¨âˆ¨Â´posâ·break

  # TODO flag for printing file and line number
  {ğ•Š: 
    iâ†posâŠ‘âŠ‘loc â‹„ lâ†iâŠ‘line â‹„ lnâ†lâŠ‘lineâŠ”src # i: position from bc to src. l: current line number. ln: current line as string
    io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ    âˆ¾âŸ¨boldCyan,file/ËœÂ¬(1Â¨â†•1-Ëœâ‰ p)âˆ¾(pâ†â€¢wdpathâˆ¾'/')â·file,':',â€¢Fmt l,reset,' ',1â†“lnâŸ© # TODO move this to repl?
    io.Out stack.Peek 1
  }âŸâŠ£ posâ·print

  {ğ•Š: dbg.Push âŸ¨file,posâŸ©}âŸâŠ£ (posâŠ‘bc)â·dbg_ops
}

_PostHookâ†{Â· _ğ•£ posâ€¿fileâ€¿stack: 
  âŸ¨cmâŸ©â†imports.Get file â‹„ bcâ€¿Â·â€¿Â·â€¿Â·â€¿Â·â€¿Â·â†cm
  {ğ•Š: dbg.Pop 1}âŸâŠ£ (posâŠ‘bc)â·dbg_ops
}

# Hooks to run in VM
hooksâ†{
  _Pre  â‡ _PreHook
  _Post â‡ _PostHook
  _Err  â‡ {vmap _ğ•£ Â·: VMCatch@ â‹„ Repl vmap}
}

# Wrap namespace to vm compatable namespace 
Import â† {
    ğ•Š ğ•©     : âŸ¨âŸ© ğ•Š ğ•©
; ğ•¨ ğ•Š âŸ¨fileâ‡fileâŸ© : imports.Has file ? (imports.Get file).Get @
; ğ•¨ ğ•Š âŸ¨fileâ‡fileâŸ© : 

    hâ†'#' # avoid breaking vims syntax highlighting
    sâ†â€¢file.Chars file 
    cm â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System ğ•¨, âŸ¨âŸ©âŸ©âŠ¸Compile)âŠ(fileâŠ¸(â€¢Exit _CmpCatch)) s
    bcâ€¿Â·â€¿blockInfoâ€¿bodyInfoâ€¿locâ€¿Â·â†cm â‹„ iâ€¿Â·â†loc # i: index of start position of bytecodes
    baâ€¿Â·â€¿Â·â€¿Â·â†instr

    m â† { # Mask of instruction starts
      n â† (â†•â‰ bc)+1+ba(âŠ£âŠËœâ‰ âŠ¸>Ã—âŠ¢)bc
      Seâ†â‰ (>/âŠ¢)âˆ¾âŸœâ‰ {(âŠËœğ•¨)ğ•ŠâŸ(â‰ â—‹(Â¯1âŠ¸âŠ‘))ğ•©âˆ¾ğ•©âŠğ•¨}âŸ¨0âŸ©Ë™
      (â‰ â†‘Â·/â¼Se) n
    }

    lâ†+`s=lf â‹„ gâ†lâŠ”s                      # line number  and grouped lines
    pg â†+`(â‰ i)â†‘/â¼âŠ‘Â¨bodyInfo
    prtâ†{âˆ¨Â´(=âŸœhâˆ¨(â‰ âˆ˜âŠ¢â†‘"---"âŠ¸â·))ğ•©}Â¨g 
    prtâ†©âˆ¾(1Â¨Â¨g)Ã—prt
    prtâ†© (â‰ i)â†‘/â¼(âˆ§i)â‹/<âŸœÂ»prt # map nearest to bytecode locations and nearest bytecode
    â€¢Show prt
    prtâ†©prtâˆ§bc=6
    #â€¢Show  prt
    #â€¢SHow âŒˆ`Â¨pgâŠ”prt
    prtâ†©/âˆ¾âŒˆ`Â¨pgâŠ”prt
    #â€¢SHow bc=6
    #â€¢Show  prt

    brkâ†{2âŠ‘3â†‘ğ•©âŠ”Ëœ+`(=âŸœhâˆ¨(â‰ âˆ˜âŠ¢â†‘"??"âŠ¸â·))ğ•©}Â¨g  
    brkâ†©âˆ¾g{(â‰ ğ•¨)â†‘(0â‰ â‰ ğ•©)Ã—(Trim 2â†“ğ•©)â·ğ•¨}Â¨brk
    brkâ†©(iâŠbrk)âˆ§6â‰ mÃ—bc                    # separate by pop instructions (6) and filter out only valid bytecode types
    brkâ†©1â†“(â†•â‰ brk)âŠ”Ëœ(0=âŠ’i)Ã—brkÃ—mÃ—+`Â»âŠ¸<brk  # group instruction sets and dedup same instructions on same line
    brkâ†©âŠ‘Â¨brk/Ëœ(0â‰ â‰ )Â¨brk                  # break only on first match in group (ie. take first of break group)

    # Saved data for imports
    nsâ†{
      line  â‡ l         # line numbers
      cols  â‡ âˆ¾(â†•â‰ )Â¨âŠ”Ëœl # column numbers
      break â‡ brk       # break point bytecode - accessed by pos
      #print â‡ prt       # print point bytecode - accessed by pos
      print â‡ âŸ¨âŸ©       # print point bytecode - accessed by pos
      cm    â‡ cm        # compilation result
      src   â‡ s         # raw source code (helps for debugging)

      Get    â‡ !âˆ˜"Import result referenced before completion"
      SetRet â‡ {ğ•Š v: Getâ†©{ğ•Š:v}}
    }

    ctx.Push file
    file imports.Set ns
    ns.SetRet retâ†hooksâ€¿{Hasâ‡0Ë™}â€¿file vm.Eval cm
    ctx.Pop 1 
    ret
; ğ•¨ ğ•Š ğ•© :  # canonicalize filename
    fileâ†'/'âŠ¸âˆ¾âŸ(Â¬âˆ˜âˆ¨Â´"./"âŠ¸â·) ğ•©
    fileâ†©ğ•©âˆ¾Ëœ(0âŠ¸â‰¢â‰ )â—¶""â€¿â€¢file.Parent ctx.Peek @     # resolve relative file location
    ğ•¨ ğ•Š {fileâ‡file}
}

Run â‡ {
  Import ğ•©
  io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ"â–¡"
}

# f: lazy function to construct hashmap of variables
Replâ‡{ğ•Š vmap:
  io.term.RawMode 1
  io.term.OutRaw â€¢ToUTF8 prompt
  io.term.Flush@

  hnâ†1-Ëœâ‰ historyâ†âŸ¨âŸ© # TODO read history from file

  vmapâ†©Vmap @ â‹„ châ†âŸ¨âŸ© â‹„ psâ†0 â‹„ contâ†0 # vmap: variable mappings. ch: character buffer. ps: cursor offset
  hooksâ†{_Preâ‡_Postâ‡{_ğ•£:@}â‹„Errâ‡VMCatch}
  bkt_nextâ†©0

  Cmdâ†{
    ch ğ•ŠÂ·: ""â‰¡Trim ch? # ignore empty statements
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœprompt
      âŸ¨âŸ©â€¿0â€¿1
  ; ch ğ•ŠÂ·:
      io.term.OutRaw clear
      io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœpromptâˆ¾ch
      inâ†"x__argâ€¿w__argâ†â€¢args â‹„ w__arg {ğ•Š:"âˆ¾châˆ¾"} x__arg" # HACK: wrap in function via string manipulation to expose ğ•Š ğ•¨ ğ•© variables 
      cm â† (âŸ¨1âŠ¸âŠ‘Â¨â€¢primitives, System vmap.GetÂ¨"ğ•©ğ•¨", vmap.Keys@âŸ©âŠ¸Compile)âŠ(""âŠ¸({ğ•Š:@}_CmpCatch)) in
      {@:1; io.Out hooksâ€¿vmapâ€¿@ vm.Eval ğ•©} cm
      hnâ†©â‰ history âˆ¾âŸœ(â‹ˆch) â†©
      âŸ¨âŸ©â€¿0â€¿1
  }

  SetHistoryâ†{
    0=â‰ history? ""â€¿0â€¿1
  ; châ†©historyâŠ‘Ëœhnâ†©(1-Ëœâ‰ history)âŒŠ0âŒˆğ•©+hn
    châ€¿(â‰ ch)â€¿1
  }
  Continueâ†{
    ğ•Š:io.term.OutRaw lfâˆ¾Ëœ"Continue"â‹„bkt_nextâ†©0
    âŸ¨âŸ©â€¿0â€¿0
  }

  Patchâ†{0=â‰ ch?âŸ¨âŸ©;âˆ¾(âˆ¾âŸœğ•©(-ğ•¨)âŠ¸â†“)Â¨âŒ¾(1âŠ¸â†‘) ps(âŠ¢âŠ”Ëœâ‰¤âŸœ(â†•â‰ ))ch} # add ğ•© into ch at ps position with ğ•¨ deletions

  # Tip: use `cat -v` in the terminal to find out key codes
  # Map of key buffer to function that returns châ€¿posâ€¿continue
  Mapâ†{ # map of inputs to âŸ¨ch, ps, effâŸ©. ch: new character list, ps: position, eff: side effect functionâŸ© 
    ğ•©:ğ•©â‰¡eâˆ¾"[D"             ? âŸ¨ch,0âŒˆps-1, 1âŸ© # arrow left
  ; ğ•©:ğ•©â‰¡eâˆ¾"[C"             ? âŸ¨ch,(â‰ ch)âŒŠps+1,1âŸ© # arrow right
  ; ğ•©:ğ•©â‰¡eâˆ¾"[A"             ? SetHistoryâŸœÂ¯1 # arrow up
  ; ğ•©:ğ•©â‰¡eâˆ¾"[B"             ? SetHistoryâŸœ1 # arrow down
  ; ğ•©:ğ•©â‰¡eâˆ¾"[46;5u"         ? {ğ•Š:bkt_nextâ†©1â‹„âŸ¨âŸ©â€¿0â€¿0} # ctrl+; next bytecode
  ; ğ•©:ğ•©â‰¡eâˆ¾"[109;5u"        ? âŸ¨âŸ¨âŸ©,0,1âŸ© # 
  ; ğ•©:ğ•©â‰¡eâˆ¾"[27;5;13~"      ? Continue # ctrl+enter
  ; ğ•©:ğ•©â‰¡â‰@+10              ? châŠ¸Cmd   # enter and run command
  ; ğ•©:ğ•©â‰¡â‰@+127             ? âŸ¨1 Patch "", 0âŒˆps-1, 1âŸ© # backspace
  ; ğ•©:ğ•©â‰¡â‰@+21              ? âŸ¨âŸ¨âŸ©,0,1âŸ© # ctrl+u
  ; ğ•©:ğ•©â‰¡â‰@+3               ? {â€¢Exit 0} # ctrl+c
  ; ğ•©:0=â‰ ch                ? âŸ¨ğ•©,1,1âŸ©
  ; ğ•©:'\'=ch(âŠ£âŠ‘Ëœ0âŒˆâ‰ âŠ¸âŒŠ)ps-1 ? zâ†uni/ËœascâˆŠğ•©
                             âŸ¨ch0â†1 Patch z, (â‰ z)+ps-1, 1âŸ© # replace '/' with unicode chars
  ; ğ•©:                       âŸ¨ch0â†0 Patch ğ•©, ps+1,      1âŸ©
  }

  # if e consume chars until letter (ANSI format parsing)
  Inputâ†{
     ğ•Š@:ğ•Šio.In@
  ;  ğ•Šğ•©:ğ•©=e?ğ•©âˆ¾eğ•Šio.In@ 
  ;  ğ•Šğ•©:âŸ¨ğ•©âŸ©
  ; eğ•Šğ•©:âŠ‘ğ•©âˆŠâˆ¾'~'âˆ¾+âŸœ(â†•26)Â¨"Aa"?ğ•©
  ; eğ•Šğ•©:ğ•©âˆ¾eğ•Šio.In@
  }

  {ğ•Š:
    effâ†Map Input@â‹„châ€¿psâ€¿contâ†©Eff@
    io.term.OutRaw clear # clear line and set to start of line
    io.term.OutRaw â€¢ToUTF8 prompt
    io.term.OutRaw â€¢ToUTF8 ch
    io.term.OutRaw eâˆ¾"["âˆ¾(â€¢Fmt (â‰ prompt)+ps+1)âˆ¾"G"
    io.term.Flush@
    cont
  }â€¢_while_ âŠ¢ 1

  io.term.OutRaw â€¢ToUTF8 lfâˆ¾Ëœ""
}
